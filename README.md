Алгоритм
Пусть задано дерево T = (V, E), где:
1) V — множество вершин (nodes)
2) E — множество рёбер (edges)
3) |V| = n — количество вершин
4) |E| = n - 1 — количество рёбер (свойство дерева)

Для каждой вершины v ∈ V введём следующие обозначения:
1)parent(v) — предок вершины v в дереве с корнем 0. Для корня parent(0) = -1 (нет предка).
2)child(v) — множество потомков v: child(v) = {u ∈ V : parent(u) = v}
3)subtree(v) — множество вершин в поддереве с корнем v: subtree(v) = {v} ∪ (⋃_{u∈child(v)} subtree(u))
4)sz[v] — размер поддерева с корнем v: sz[v] = |subtree(v)|.  Для листа sz[leaf] = 1
5)depth(v) — расстояние от корня 0 до вершины v: depth(0) = 0. depth(v) = depth(parent(v)) + 1 для v ≠ 0
6)ans[v] — искомая величина: сумма расстояний от v до всех вершин: ans[v] = Σ_{u∈V} dist(v, u)

По определению для корня 0: ans[0] = Σ_{v∈V} depth(v)

Лемма 1 (Рёберный вклад).
Сумма глубин всех вершин равна сумме размеров поддеревьев всех вершин, кроме корня: Σ_{v∈V} depth(v) = Σ_{v≠0} sz[v]

Доказательство:
Рассмотрим произвольное ребро e = (parent, child) в дереве. Каждая вершина из поддерева child, включая саму child, проходит через это ребро ровно один раз на пути к корню. Количество таких вершин = sz[child].
Следовательно, вклад ребра e в сумму глубин = sz[child].
Суммируя по всем рёбрам (их n-1), получаем:
Σ_{v∈V} depth(v) = Σ_{каждому ребру (p,c)} sz[c] = Σ_{v≠0} sz[v] ■

Следствие. 
Для вычисления ans[0] достаточно знать sz[v] для всех v≠0.

Лемма 2 (Рекуррентная формула для sz). 
Для любой вершины v: sz[v] = 1 + Σ_{u∈child(v)} sz[u]

Доказательство:
Поддерево v состоит из самой вершины v (1 вершина) и всех поддеревьев её детей (Σ sz[u] вершин)
Складывая, получаем формулу. ■

Лемма 3 (Пост-порядок). 
Если вершины обрабатываются в порядке "сначала дети, потом родитель" (пост-порядок), то при обработке v все sz[child] уже известны.

Доказательство.
В пост-порядке дети всегда обрабатываются раньше родителя.
Следовательно, к моменту обработки v значения sz для всех её детей
уже вычислены. ■

Пусть известен ответ ans[p] для некоторой вершины p.
Рассмотрим её ребёнка c. Выведем формулу для ans[c].

Теорема 1 (Перенос корня). 
При перемещении корня из p в c: ans[c] = ans[p] + n - 2·sz[c]

Доказательство:
Разобьём множество всех вершин V на два непересекающихся подмножества:
1.A = subtree(c) — поддерево вершины c
2.B = V \ A — все остальные вершины

По определению:
         |A| = sz[c]
         |B| = n - sz[c]

Рассмотрим, как изменяется расстояние до произвольной вершины x 
при переносе корня из p в c.

Случай 1: x ∈ A (вершина в поддереве c)
         До переноса: dist(p, x) = 1 + dist(c, x)
         После переноса: dist(c, x) = dist(p, x) - 1
         Изменение для каждой x ∈ A: -1
         Суммарное изменение для всех x ∈ A: -|A| = -sz[c]

Случай 2: x ∈ B (вершина вне поддерева c)
         До переноса: dist(p, x) = dist(c, x) - 1
         После переноса: dist(c, x) = dist(p, x) + 1
         Изменение для каждой x ∈ B: +1
         Суммарное изменение для всех x ∈ B: +|B| = +(n - sz[c])

Общее изменение суммы расстояний: Δ = -sz[c] + (n - sz[c]) = n - 2·sz[c]
Следовательно: ans[c] = ans[p] + Δ = ans[p] + n - 2·sz[c] ■

Следствие. 
Зная ans[0] и все sz[v], можно вычислить ans для всех вершин, обходя дерево от корня к листьям (пре-порядок).

На основе доказанных утверждений строится следующий алгоритм:

Шаг 1. Построение порядка обхода (BFS)
1)Выполнить обход в ширину из корня 0
2)Для каждой вершины v запомнить parent[v]
3)Сохранить порядок обхода order[] (пре-порядок BFS)

Шаг 2. Вычисление размеров поддеревьев и ans[0]
1)Взять order в обратном порядке (получаем пост-порядок)
2)Для каждой вершины v (от листьев к корню):
       Для каждого ребёнка u вершины v:
         sz[v] += sz[u] (по Лемме 2)
         ans[0] += sz[u] (по Лемме 1)

Шаг 3. Вычисление ответов для всех вершин
1)Вернуть order в исходный порядок (пре-порядок)
2)Для каждой вершины v (от корня к листьям):
       Для каждого ребёнка u вершины v:
         ans[u] = ans[v] + n - 2·sz[u]  (по Теореме 1)

Асимптотика
Временная сложность

Оценим количество операций для каждого этапа:

Шаг 1 (BFS обход):
1)Каждая вершина ровно 1 раз помещается в очередь и извлекается: O(n)
2)Для каждой вершины просматриваются все её соседи
3)Сумма степеней всех вершин = 2|E| = 2(n-1) = O(n)
   Итого по шагу 1: O(n)

Шаг 2 (Обратный проход):
1)reverse(order): O(n)
2)Проход по всем вершинам в order: n итераций
3)Для каждой вершины просматриваются все соседи
4)Снова сумма степеней = O(n)
   Итого по шагу 2: O(n) + O(n) = O(n)

Шаг 3 (Прямой проход):
1)reverse(order): O(n)
2)Проход по всем вершинам: n итераций
3)Для каждой вершины просматриваются все соседи
4)Сумма степеней = O(n)
   Итого по шагу 3: O(n) + O(n) = O(n)

Общая сложность: O(n) + O(n) + O(n) = O(n)

Затраты памяти

Оценим объём используемой памяти:

ГРАФ g:
1)Вектор векторов размера n
2)Каждое ребро хранится дважды (в обе стороны)
3)Всего 2(n-1) элементов типа int
   Память: O(n)

МАССИВ sz:
n элементов типа int (4 байта) = 4n байт
   Память: O(n)

МАССИВ ans:
n элементов типа int = 4n байт
   Память: O(n)

МАССИВ parent:
n элементов типа int = 4n байт
   Память: O(n)

МАССИВ order:
n элементов типа int = 4n байт
   Память: O(n)

ОЧЕРЕДЬ BFS:
1)В худшем случае (корень со всеми детьми) содержит n-1 элементов
2)n элементов типа int = 4n байт
   Память: O(n)

Общие затраты памяти: 5·4n + 4n + O(1) = 24n + O(1) = O(n)
